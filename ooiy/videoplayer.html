<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>OOIY X-TREME 5.1: BRIGHT NEON DISCO PLAYER</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

<style>
    /* --- 1. CORE & BACKGROUND (FULL VIEWPORT LAYOUT) --- */
    * { 
        box-sizing: border-box; 
        outline: none; 
        /* Use a vendor prefix for better cross-browser compatibility */
        -webkit-tap-highlight-color: transparent; /* Removes blue/grey tap highlight on some Androids */
    }
    
    body {
        margin: 0; background-color: #000; font-family: 'Segoe UI', sans-serif;
        display: flex; justify-content: center; align-items: center;
        /* CRITICAL FIX: Use vh and vw for initial layout, but ensure 100vh works properly on mobile */
        /* For 100vh fix on mobile (due to address bar), use JS, but this CSS is the start: */
        height: 100vh; 
        width: 100vw; 
        overflow: hidden; 
        color: #fff;
    }
    
    /* CRITICAL MOBILE FIX: Define the full-screen height via a CSS variable set by JS */
    html {
        --vh: 100vh;
    }
    body {
        height: var(--vh); /* Use the new variable for height */
    }

    .bg-anim {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle at 50% 50%, #0f001f 0%, #000000 90%);
        transition: background 0.1s ease, transform 0.1s linear; 
        z-index: -2;
        animation: bgRotate 60s linear infinite; 
    }
    @keyframes bgRotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    #bg-visualizer { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
        pointer-events: none;
        opacity: 0.6;
    }

    /* --- 2. THE PLAYER CARD (DYNAMIC SOFT NEON GLOWING BORDER) --- */
    .player-card {
        position: relative; 
        /* CRITICAL FIX: Mobile view is now full screen, so 100% width/height is correct */
        width: 100%; height: 100%; 
        background: rgba(0, 0, 0, 0);
        border-radius: 0;
        display: flex; flex-direction: column; align-items: center;
        justify-content: space-between; padding: 0; z-index: 10;
        
        border-style: solid;
        border-width: 20px;
        border-color: #FF00FF; 
        transition: border-color 0.05s ease, box-shadow 0.05s ease;
        
        box-shadow: none; 
        animation: none;
    }

    /* Header & Video */
    .header {
        position: absolute; top: 0; left: 0; right: 0; 
        padding: 15px 30px; 
        display: flex; justify-content: space-between; align-items: center;
        z-index: 30; 
        background: linear-gradient(to bottom, rgba(0,0,0,0.7), rgba(0,0,0,0));
        opacity: 1; 
        pointer-events: all;
        transition: opacity 0.5s ease-in-out; 
    }
    .header.hide {
        opacity: 0;
        pointer-events: none;
    }
    .logo { font-size: 20px; font-weight: bold; color: #00ffff; }
    .upload-group { display: flex; gap: 10px; } 
    .upload-btn {
        padding: 8px 15px; background: rgba(0,0,0,0.5); border: 2px solid #ff00ff;
        border-radius: 5px; cursor: pointer; font-size: 14px;
        transition: 0.2s;
        /* CRITICAL MOBILE FIX: Smaller font and padding for smaller screens */
        font-size: 12px;
        padding: 5px 10px;
    }
    .upload-btn:hover { background: #ff00ff; color: #000; }
    #videoFile, #subtitleFile { display: none; } 

    .video-wrapper {
        position: relative;
        width: 100%; height: 100%;
        background: #000;
        overflow: hidden;
        display: flex; justify-content: center; align-items: center;
        
        box-shadow: none; 
        transition: box-shadow 0.05s ease, transform 0.08s ease; /* Added transform transition for smoother shake reset */
    }
    
    #videoPlayer {
        width: 100%;
        height: 100%;
        object-fit: cover; 
        cursor: pointer;
    }
    
    /* Controls */
    .controls-area {
        position: absolute; bottom: 0; left: 0; right: 0;
        padding: 15px 15px 20px; /* CRITICAL MOBILE FIX: Reduce horizontal padding */
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 15px;
        z-index: 20;
        pointer-events: all; 
        opacity: 1;
        transition: opacity 0.3s ease-in-out;
        background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0));
    }
    .controls-area.hide {
        opacity: 0;
        pointer-events: none; 
    }

    .progress-container {
        width: 100%; display: flex; align-items: center; gap: 10px;
        order: 1;
    }
    .time-display { font-size: 12px; font-weight: bold; width: 40px; } /* CRITICAL MOBILE FIX: Smaller font and width */

    .progress-bar-modern {
        /* ... (Keep existing progress bar styles) ... */
        -webkit-appearance: none;
        width: 100%;
        height: 4px; 
        background: rgba(255, 255, 255, 0.2); 
        border-radius: 2px;
        cursor: pointer;
        overflow: hidden;
    }

    .progress-bar-modern::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 4px;
        width: 10px; 
        background: #00ffff;
        box-shadow: -400px 0 0 400px #ff00ff;
    }
    .progress-bar-modern::-moz-range-thumb {
        background: #ff00ff;
        border: none;
        border-radius: 0;
    }
    .progress-bar-modern::-moz-range-track {
        background: rgba(255, 255, 255, 0.2);
    }
    
    .utility-bar {
        width: 100%; display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 5px; order: 0; 
        /* CRITICAL MOBILE FIX: Allow wrapping if needed, but flex-shrink to fit */
        flex-wrap: nowrap; 
    }
    .main-buttons {
        /* CRITICAL MOBILE FIX: Reduce gap for better fit */
        display: flex; justify-content: center; align-items: center; gap: 20px;
        order: 2; 
    }
    .btn {
        color: #fff; 
        font-size: 20px; /* CRITICAL MOBILE FIX: Smaller size for utility buttons */
        cursor: pointer; transition: 0.2s;
        opacity: 0.8;
    }
    .btn:hover { opacity: 1; color: #ff00ff; transform: scale(1.1); text-shadow: 0 0 15px #ff00ff;}

    /* New Beat Button Style */
    #beatBtn {
        font-size: 16px; /* CRITICAL MOBILE FIX: Smaller font for BEAT button text */
        color: #ff00ff; 
        padding: 4px 8px; /* CRITICAL MOBILE FIX: Smaller padding */
        border: 2px solid #ff00ff;
        border-radius: 5px;
        transition: 0.1s;
    }
    #beatBtn:hover {
        opacity: 1;
        color: #fff;
        background-color: #ff00ff;
        box-shadow: 0 0 10px #ff00ff;
        transform: scale(1.05);
    }
    
    .play-btn-large {
        font-size: 50px; /* CRITICAL MOBILE FIX: Smaller size for main play button */
        opacity: 1;
        background: linear-gradient(to right, #00ffff, #ff00ff);
        -webkit-background-clip: text; color: transparent;
        filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
    }
    .play-btn-large:hover { transform: scale(1.05); filter: drop-shadow(0 0 25px #00ffff); }
    
    /* Volume Bar & Zoom Buttons */
    #volumeBar {
        width: 80px !important; /* CRITICAL MOBILE FIX: Max width */
        height: 2px;
    }
    .main-buttons button {
        /* CRITICAL MOBILE FIX: Style zoom buttons to match other buttons */
        background: none;
        border: none;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
        opacity: 0.8;
        padding: 5px;
        transition: 0.2s;
    }
    .main-buttons button:hover { opacity: 1; color: #ff00ff; transform: scale(1.1); text-shadow: 0 0 15px #ff00ff;}

    /* --- CC OVERLAY (VLC Style) --- */
    #cc-overlay {
        position: absolute; 
        bottom: 15%; /* CRITICAL MOBILE FIX: Increase distance from bottom for better visibility over controls */
        left: 50%; 
        transform: translateX(-50%);
        text-align: center; 
        padding: 5px 10px; 
        
        background: rgba(0, 0, 0, 0.5); 
        color: white; 
        font-size: 20px; /* CRITICAL MOBILE FIX: Smaller font size */
        font-weight: 800; 
        
        text-shadow: 2px 2px 4px #000, -2px -2px 4px #000, 2px -2px 4px #000, -2px 2px 4px #000;
        
        border-radius: 5px; 
        max-width: 90%; 
        display: none; 
        pointer-events: none; 
        z-index: 40;
    }
</style>
</head>

<body>

<div class="bg-anim" id="bgAnim">
    <canvas id="bg-visualizer"></canvas>
</div>

<div class="player-card" id="card">
    <div class="header" id="headerArea"> 
        <div class="logo">OOIY X-TREME 5.1</div>
        <div class="upload-group">
            <label class="upload-btn" for="subtitleFile" title="Load Subtitles">
                <i class="fa-solid fa-closed-captioning"></i> SUB
            </label>
            <label class="upload-btn" for="videoFile" title="Load Video">
                <i class="fa-solid fa-film"></i> VIDEO
            </label>
        </div>
        <input type="file" id="videoFile" accept="video/*">
        <input type="file" id="subtitleFile" accept=".srt, .vtt">
        
    </div>
    
    <div class="video-wrapper" id="videoWrapper">
        <video id="videoPlayer" preload="metadata" playsinline poster="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"> 
             <track id="manualTrack" kind="subtitles" srclang="en" label="OOIY Subtitles" default> 
        </video>
        <div id="cc-overlay"></div> 
    </div>

    <div class="controls-area" id="controlsArea">
        <div class="utility-bar">
            <div style="display: flex; align-items: center; gap: 5px;">
                <i class="fa-solid fa-volume-high btn" id="muteBtn" title="Mute/Unmute"></i>
                <input type="range" id="volumeBar" value="100" min="0" max="100">
                <i class="fa-solid fa-heart-pulse btn" id="beatBtn" title="Trigger Beat Color"> BEAT</i>
            </div>

            <div style="display: flex; align-items: center; gap: 15px;">
                <i class="fa-solid fa-closed-captioning btn" id="ccBtn" title="Closed Captions"></i>
                <i class="fa-solid fa-repeat btn" id="loopBtn" title="Loop: Off"></i>
                <i class="fa-solid fa-gauge-high btn" id="speedBtn" title="Playback Speed"></i>
                <i class="fa-solid fa-maximize btn" id="fullscreenBtn" title="Fullscreen"></i>
            </div>
        </div>
        
        <div class="main-buttons">
            <button id="zoomOutBtn" title="Zoom Out"><i class="fa-solid fa-minus"></i></button>
            <i class="fa-solid fa-rotate-left btn" id="rewindBtn" title="-10s"></i>
            <i id="playBtn" class="fa-solid fa-circle-play btn play-btn-large"></i>
            <i class="fa-solid fa-rotate-right btn" id="forwardBtn" title="+10s"></i>
            <button id="zoomInBtn" title="Zoom In"><i class="fa-solid fa-plus"></i></button>

        </div>

        <div class="progress-container">
            <span class="time-display" id="currTime">0:00</span>
            <input type="range" id="progressBar" class="progress-bar-modern" value="0" min="0" max="100" step="0.1">
            <span class="time-display" id="durTime">0:00</span>
        </div>
    </div>
</div>

<script>
    /* --- JS SETUP --- */
    const card              = document.getElementById("card");
    const videoWrapper      = document.getElementById("videoWrapper");
    const fileInput         = document.getElementById("videoFile"); 
    const subtitleInput     = document.getElementById("subtitleFile"); 
    const videoPlayer       = document.getElementById("videoPlayer");
    const playBtn           = document.getElementById("playBtn");
    const progressBar       = document.getElementById("progressBar");
    const currTimeEl        = document.getElementById("currTime");
    const durTimeEl         = document.getElementById("durTime");
    const muteBtn           = document.getElementById("muteBtn");
    const volumeBar         = document.getElementById("volumeBar");
    const fullscreenBtn     = document.getElementById("fullscreenBtn");
    const rewindBtn         = document.getElementById("rewindBtn");
    const forwardBtn        = document.getElementById("forwardBtn");
    const speedBtn          = document.getElementById("speedBtn");
    const controlsArea      = document.getElementById("controlsArea");
    const bgAnim            = document.getElementById("bgAnim");
    const ccBtn             = document.getElementById("ccBtn");
    const ccOverlay         = document.getElementById("cc-overlay");
    const loopBtn           = document.getElementById("loopBtn");
    const bgVisualizer      = document.getElementById("bg-visualizer");
    const visCtx            = bgVisualizer.getContext("2d");
    const headerArea        = document.getElementById("headerArea"); 
    const manualTrack       = document.getElementById("manualTrack");
    const beatBtn           = document.getElementById("beatBtn"); 

    const zoomInBtn         = document.getElementById("zoomInBtn");
    const zoomOutBtn        = document.getElementById("zoomOutBtn");
    
    let isPlaying = false;
    let isLooping = false;
    let audioCtx, analyser, src;
    let dataArray, bufferLength;
    let controlsHideTimeout;
    let audioIsSetup = false;
    let headerHideTimeout; 
    let cueListeners = []; 
    let isBeatOn = false; 
    let isCCToggled = false;
    
    let currentZoom = 1.0;
    const ZOOM_STEP = 0.2;
    const MAX_ZOOM = 3.0;
    const MIN_ZOOM = 1.0;

    /* -----------------------------------------------------
        --- CRITICAL MOBILE FIX: Set 100vh accurately ---
        ----------------------------------------------------- */
    function setFullViewportHeight() {
        // Get the height of the viewport (excluding mobile browser bars)
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${window.innerHeight}px`);
        resizeCanvas();
    }
    window.addEventListener('resize', setFullViewportHeight);
    window.addEventListener('orientationchange', setFullViewportHeight); // Recalculate on orientation change
    setFullViewportHeight(); // Call once on load

    // --- UTILITIES & Controls ---
    function fmtTime(s) {
        if (isNaN(s)) return "0:00";
        const m = Math.floor(s/60);
        const sc = Math.floor(s%60);
        return m + ":" + (sc<10?"0"+sc:sc);
    }
    
    function resizeCanvas() {
        bgVisualizer.width = bgVisualizer.clientWidth;
        bgVisualizer.height = bgVisualizer.clientHeight;
    }
    resizeCanvas();

    function showControls() {
        controlsArea.classList.remove('hide');
        clearTimeout(controlsHideTimeout);
        if (isPlaying) {
            controlsHideTimeout = setTimeout(() => {
                controlsArea.classList.add('hide');
            }, 3000); 
        }

        headerArea.classList.remove('hide');
        clearTimeout(headerHideTimeout);
        if (isPlaying && videoPlayer.src) { 
            headerHideTimeout = setTimeout(() => {
                headerArea.classList.add('hide');
            }, 3000);
        }
    }

    // Controls will show on mouse movement OR touch start
    card.addEventListener('mousemove', showControls);
    card.addEventListener('touchstart', showControls); // CRITICAL MOBILE FIX
    videoPlayer.addEventListener('pause', showControls);
    videoPlayer.addEventListener('play', showControls);

    // --- NEW: Toggle UI visibility on click/touch ---
    videoPlayer.onclick = () => {
        if (!videoPlayer.src) return; 

        if (isPlaying) {
            // Pause/Play Toggle is handled by the main button now for consistency,
            // but this click still toggles UI visibility on playing video
            if (!controlsArea.classList.contains('hide')) {
                controlsArea.classList.add('hide');
                headerArea.classList.add('hide');
                clearTimeout(controlsHideTimeout);
                clearTimeout(headerHideTimeout);
            } else {
                // If controls are hidden, click brings them back up
                showControls();
            }
        } else {
            playVideo();
        }
    };
    
    // The play button explicitly toggles play/pause 
    playBtn.onclick = () => { 
        // CRITICAL MOBILE FIX: If AudioContext is not set up, do it here with the first user gesture
        if(!audioIsSetup && videoPlayer.src) setupAudioContext(); 

        if(isPlaying) pauseVideo(); else playVideo(); 
    };


    fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if(!file) return;
        videoPlayer.src = URL.createObjectURL(file);
        videoPlayer.load();
        
        // Setup Audio Context - it will be initialized as 'suspended' on mobile
        if(!audioIsSetup) setupAudioContext();

        // 1. Clear any previous subtitle state/listeners
        manualTrack.mode = 'disabled';
        ccOverlay.innerText = "";
        ccOverlay.style.display = 'none';
        isCCToggled = false;
        ccBtn.style.color = '#fff';

        // Do NOT auto-play here, let the user tap the play button to satisfy mobile gesture requirements
        // playVideo(); 
        
        // This is a common issue with local file loading on some mobile browsers
        // It's better to unmute/set volume AFTER user taps play.
        // setTimeout(() => videoPlayer.muted = false, 500); 
        
        showControls();
        // Inform the user
    };


    // --- Subtitle SRT/VTT Loading Logic (No change needed here) ---
    function srtToVtt(data) {
        data = data.replace(/\{\\.*\}/g, '').trim();
        data = data.replace(/,/g, '.');
        const lines = data.split('\n');
        const filteredLines = lines.filter(line => !/^\d+$/.test(line.trim()));
        let vtt = 'WEBVTT\n\n' + filteredLines.join('\n');
        vtt = vtt.replace(/\n\s*\n\n/g, '\n\n'); 
        return vtt;
    }

    subtitleInput.onchange = function(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            let fileContent = event.target.result;
            const fileName = file.name.toLowerCase();

            if (fileName.endsWith('.srt')) {
                fileContent = srtToVtt(fileContent);
            } else if (!fileName.endsWith('.vtt')) {
                alert("Unsupported subtitle file type. Please use .srt or .vtt.");
                return;
            }

            const vttBlob = new Blob([fileContent], { type: 'text/vtt' });
            const vttUrl = URL.createObjectURL(vttBlob);

            if (manualTrack.src) URL.revokeObjectURL(manualTrack.src);

            let existingTrack = videoPlayer.querySelector('track[label="Uploaded Subtitles"]');
            if (existingTrack) {
                existingTrack.remove();
            }

            const track = document.createElement('track');
            track.kind = 'subtitles';
            track.srclang = 'en';
            track.label = 'Uploaded Subtitles';
            track.src = vttUrl;
            videoPlayer.appendChild(track);
            
            manualTrack.mode = 'disabled';
            ccOverlay.style.display = 'none';
            ccBtn.style.color = '#fff'; 

            track.addEventListener('load', () => {
                track.mode = 'showing'; 
                ccBtn.style.color = '#00ffff'; 
                isCCToggled = true; 
                setupVlcStyleCueHandling(track); 
            });
        };
        reader.readAsText(file); 
    };

    function setupVlcStyleCueHandling(trackElement) {
        const textTrack = trackElement.track;
        
        cueListeners.forEach(listener => textTrack.removeEventListener('cuechange', listener));
        cueListeners = []; 

        textTrack.mode = 'hidden';

        const cueChangeListener = () => {
            if (!isCCToggled) return; 

            if (textTrack.activeCues.length > 0) {
                const cue = textTrack.activeCues[0];
                ccOverlay.innerText = cue.text;
                ccOverlay.style.display = 'block';
            } else {
                ccOverlay.innerText = "";
                ccOverlay.style.display = 'none';
            }
        };

        textTrack.addEventListener('cuechange', cueChangeListener);
        cueListeners.push(cueChangeListener);
    }
    // --- END Subtitle Logic ---

    // --- Video Zoom Logic (No change needed here) ---
    function updateZoom() {
        videoWrapper.style.transform = `scale(${currentZoom})`;
        // Reset shake transform if applied by beat
        if (!isBeatOn) {
            videoWrapper.style.transform = `scale(${currentZoom})`;
        } 
    }

    if (zoomInBtn) {
        zoomInBtn.onclick = () => {
            currentZoom = Math.min(MAX_ZOOM, currentZoom + ZOOM_STEP);
            updateZoom();
        };
    }

    if (zoomOutBtn) {
        zoomOutBtn.onclick = () => {
            currentZoom = Math.max(MIN_ZOOM, currentZoom - ZOOM_STEP);
            updateZoom();
        };
    }


    /* -----------------------------------------------------
        --- EXISTING CONTROLS/FEATURES ---
        ----------------------------------------------------- */

    function playVideo() {
        if(!videoPlayer.src) return alert("Please Load a Video Track first.");
        
        // CRITICAL MOBILE FIX: Resume AudioContext on play, which requires user gesture
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                console.log("AudioContext resumed successfully.");
            }).catch(e => console.error("AudioContext Resume Error:", e));
        }

        videoPlayer.play().catch(e => console.error("Video Play Error:", e));
        isPlaying = true;
        playBtn.className = "fa-solid fa-circle-pause btn play-btn-large";
        renderVisuals();
        showControls();
    }

    function pauseVideo() {
        videoPlayer.pause();
        isPlaying = false;
        playBtn.className = "fa-solid fa-circle-play btn play-btn-large";
        clearTimeout(controlsHideTimeout);
        clearTimeout(headerHideTimeout); 
        showControls(); 
    }

    videoPlayer.ontimeupdate = () => {
        if(videoPlayer.duration && !isNaN(videoPlayer.duration)) {
            if (progressBar !== document.activeElement) { 
                const pct = (videoPlayer.currentTime / videoPlayer.duration) * 100;
                progressBar.value = pct;
            }
            currTimeEl.innerText = fmtTime(videoPlayer.currentTime);
            durTimeEl.innerText = fmtTime(videoPlayer.duration);
        }
    };

    progressBar.addEventListener('input', () => {
        const time = (progressBar.value / 100) * videoPlayer.duration;
        videoPlayer.currentTime = time;
    });

    // Mute/Volume
    muteBtn.onclick = () => {
        videoPlayer.muted = !videoPlayer.muted;
        muteBtn.className = videoPlayer.muted ? "fa-solid fa-volume-off btn" : "fa-solid fa-volume-high btn";
        volumeBar.value = videoPlayer.muted ? 0 : videoPlayer.volume * 100;
    };
    volumeBar.oninput = () => {
        videoPlayer.volume = volumeBar.value / 100;
        videoPlayer.muted = volumeBar.value == 0;
        muteBtn.className = videoPlayer.muted ? "fa-solid fa-volume-off btn" : "fa-solid fa-volume-high btn";
    };

    // Fast Forward/Rewind
    rewindBtn.onclick = () => { videoPlayer.currentTime -= 10; };
    forwardBtn.onclick = () => { videoPlayer.currentTime += 10; };

    // Speed
    let currentSpeedIndex = 1; // 1.0
    const speeds = [0.5, 1.0, 1.5, 2.0];
    speedBtn.onclick = () => {
        currentSpeedIndex = (currentSpeedIndex + 1) % speeds.length;
        const newSpeed = speeds[currentSpeedIndex];
        videoPlayer.playbackRate = newSpeed;
        speedBtn.title = `Playback Speed: ${newSpeed}x`;
        speedBtn.style.color = newSpeed === 1.0 ? '#fff' : '#00ffff';
    };

    // Loop
    loopBtn.onclick = () => {
        isLooping = !isLooping;
        videoPlayer.loop = isLooping;
        loopBtn.style.color = isLooping ? '#ff00ff' : '#fff';
        loopBtn.title = `Loop: ${isLooping ? 'On' : 'Off'}`;
    };

    // CC Toggle
    ccBtn.onclick = () => {
        // Toggles the custom VTT handling ON/OFF (logic remains the same)
        isCCToggled = !isCCToggled;
        const trackElement = videoPlayer.querySelector('track[label="Uploaded Subtitles"]');
        
        if (trackElement) {
            if (isCCToggled) {
                ccBtn.style.color = '#00ffff';
                trackElement.track.mode = 'hidden'; 
            } else {
                ccBtn.style.color = '#fff';
                ccOverlay.style.display = 'none';
                ccOverlay.innerText = "";
            }
        } else {
             ccBtn.style.color = isCCToggled ? '#00ffff' : '#fff';
             if (isCCToggled) {
                 ccOverlay.innerText = "CC ON: Please load an SRT or VTT subtitle file.";
                 ccOverlay.style.display = 'block';
             } else {
                 ccOverlay.style.display = 'none';
                 ccOverlay.innerText = "";
             }
        }
    };
    

    fullscreenBtn.onclick = () => {
        // Use card for fullscreen on mobile for a full viewport experience
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            card.requestFullscreen().catch(e => {
                console.error("Fullscreen failed:", e);
                alert("Fullscreen failed. Ensure browser settings allow it.");
            });
        }
    };


    /* -----------------------------------------------------
        --- AUDIO SYSTEM & DYNAMIC EFFECTS (Beat Fix) ---
        ----------------------------------------------------- */
    function setupAudioContext() {
        // CRITICAL MOBILE FIX: Check for existing context and resume if necessary, otherwise create new
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            src = audioCtx.createMediaElementSource(videoPlayer);
            analyser = audioCtx.createAnalyser();
            src.connect(analyser);
            analyser.connect(audioCtx.destination);
            
            analyser.fftSize = 512;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            audioIsSetup = true;

            if (audioCtx.state === 'suspended') {
                // Inform the user that a gesture is needed to enable the full experience
                console.log("AudioContext is suspended. Will attempt to resume on first play.");
            }
        } catch(e) {
            console.error("AudioContext setup failed:", e);
            alert("Audio features (Visuals/Beat) are disabled. AudioContext initialization failed.");
        }
    }

    const colorPalette = [
    '#FF00FF','#FFFF00','#00FFFF','#FF0000','#00FF00','#0000FF','#FFA500',
    // ... (rest of the color palette is unchanged)
    '#FF00D2','#FF00B3','#FF0094','#FF0075','#FF0056','#FF0038','#FF2200','#FF4A00',
    '#FF7300','#FF9900','#FFBC00','#FFDF00','#FCFF00','#D1FF00',
    '#AFFF00','#8DFF00','#66FF00','#00FF66','#00FFA8','#00FFEA',
    '#00CCFF','#008CFF','#0050FF','#3500FF','#6500FF','#9400FF',
    '#C400FF','#F400FF'
    ];

    let colorIndex = 0;
    let lastBeatTime = 0;
    const BASS_THRESHOLD_MIN = 120;
    const BASS_THRESHOLD_MAX = 200;
    const INTERVAL_MAX = 1500;
    const INTERVAL_MIN = 10;
    const SHAKE_AMOUNT = 5; 

    function triggerNeonFlash() {
        const flashColor = '#FFFFFF';
        card.style.transition = 'box-shadow 0.01s ease, background-color 0.01s ease';
        card.style.backgroundColor = flashColor;
        card.style.boxShadow = `0 0 100px 50px ${flashColor}, inset 0 0 100px 50px ${flashColor}`;
        card.style.filter = 'brightness(1.5)';
        
        setTimeout(() => {
            card.style.transition = 'border-color 0.05s ease, box-shadow 0.05s ease, background-color 0.5s ease';
            card.style.backgroundColor = 'rgba(0, 0, 0, 0)'; 
            card.style.boxShadow = 'none'; 
            card.style.filter = 'none'; 
        }, 50); 
    }

    function triggerBeat() {
        colorIndex = (colorIndex + 1) % colorPalette.length;
        const newColor = colorPalette[colorIndex];
        applyDiscoEffects(newColor);
        lastBeatTime = Date.now();

        if (isBeatOn) {
            shakeVideo();
            if (Math.random() < 0.1) { 
                 triggerNeonFlash();
            }
        }
    }

    function shakeVideo() {
        const xOffset = Math.random() * SHAKE_AMOUNT * 2 - SHAKE_AMOUNT; 
        const yOffset = Math.random() * SHAKE_AMOUNT * 2 - SHAKE_AMOUNT; 

        // Apply shake transform to the video wrapper, maintaining current zoom
        videoWrapper.style.transform = `translate(${xOffset}px, ${yOffset}px) scale(${currentZoom * 1.01})`;
        
        setTimeout(() => {
            // Reset position, but keep the current zoom level
            videoWrapper.style.transform = `translate(0, 0) scale(${currentZoom})`;
        }, 80); 
    }
    
    // Beat button logic is now cleaner and ensures AudioContext is setup/resumed on tap.
    beatBtn.onclick = function() {
        if (!videoPlayer.src) return alert("Please Load a Video Track first.");
        
        if(!audioIsSetup) {
            setupAudioContext(); // Setup context if it wasn't done on file load
        }
        
        // CRITICAL MOBILE FIX: Resume the AudioContext here on user interaction
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                console.log("AudioContext resumed by BEAT button.");
            }).catch(e => console.error("AudioContext Resume Error:", e));
        }

        isBeatOn = !isBeatOn;

        if (isBeatOn) {
            beatBtn.style.backgroundColor = '#ff00ff'; 
            beatBtn.style.color = '#000';
            beatBtn.innerText = 'BEAT ON';

            const pulseCount = 8; 
            const intervalMs = 50; 
            let count = 0;

            const pulse = setInterval(() => {
                triggerBeat(); 
                bgAnim.style.transform = `scale(1.05)`; 
                
                count++;
                if (count >= pulseCount) {
                    clearInterval(pulse);
                    
                    setTimeout(() => {
                        // Reset background scale after pulse, if not playing/no audio context
                        if (!isPlaying || !audioIsSetup) {
                            bgAnim.style.transform = `scale(1)`;
                        }
                    }, intervalMs); 
                }
            }, intervalMs);

        } else {
            beatBtn.style.backgroundColor = 'rgba(0,0,0,0.5)'; 
            beatBtn.style.color = '#ff00ff'; 
            beatBtn.innerText = 'BEAT';
            
            // Ensure video wrapper is reset to current zoom level (no shake/transform)
            videoWrapper.style.transform = `translate(0, 0) scale(${currentZoom})`;
        }
    };

    function applyDiscoEffects(newColor) {
        card.style.borderColor = newColor; 
        videoWrapper.style.boxShadow = `inset 0 0 70px -10px ${newColor}`;
        bgAnim.style.background = `radial-gradient(circle at 50% 50%, ${newColor} 0%, #000000 100%)`;
    }

    function renderVisuals() {
        // CRITICAL FIX: Add check for suspended context
        if(!isPlaying || !audioIsSetup || audioCtx.state !== 'running') {
            // Only continue to request the next frame if the player is technically paused
            if (isPlaying) requestAnimationFrame(renderVisuals); 
            return;
        }

        requestAnimationFrame(renderVisuals);
        
        analyser.getByteFrequencyData(dataArray);
        
        const w = bgVisualizer.width;
        const h = bgVisualizer.height;
        const center = { x: w / 2, y: h / 2 };

        let bass = 0;
        for(let i=0; i<15; i++) bass += dataArray[i]; 
        bass = bass / 15; 
        
        const currentTime = Date.now();

        let normalizedBass = (bass - BASS_THRESHOLD_MIN) / (BASS_THRESHOLD_MAX - BASS_THRESHOLD_MIN);
        normalizedBass = Math.max(0, Math.min(1, normalizedBass));

        const dynamicInterval = INTERVAL_MAX - (normalizedBass * (INTERVAL_MAX - INTERVAL_MIN));

        if(currentTime - lastBeatTime > dynamicInterval) {
            triggerBeat();
        } 
        
        visCtx.clearRect(0, 0, w, h);
        const radius = Math.max(w, h) * 0.15;
        
        for (let i = 0; i < bufferLength; i += 4) {
            const bar = dataArray[i];
            const hue = (i * 2 + Date.now() * 0.02) % 360;

            visCtx.beginPath();
            visCtx.arc(center.x, center.y, radius + i * 0.4 + bar*0.2, 0, Math.PI * 2);
            visCtx.fillStyle = `hsla(${hue}, 100%, 70%, 0.05)`;
            visCtx.fill();
        }

        let sum = 0;
        for(let i=0; i<bufferLength; i++) sum += dataArray[i];
        const avgVolume = sum / bufferLength;
        const volumeScale = 1 + (avgVolume / 255) * 0.03;
        bgAnim.style.transform = `scale(${volumeScale})`;
    }

    // INITIALIZATION
    document.addEventListener('DOMContentLoaded', () => { 
        controlsArea.classList.add('hide'); 
        applyDiscoEffects(colorPalette[colorIndex]);

        setTimeout(() => {
            headerArea.classList.add('hide');
        }, 3000); 
    });

</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            min-height: 100vh;
            color: #fff;
            display: flex;
            flex-direction: column;
        }

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            z-index: 100;
        }

        .top-bar h1 {
            font-size: 1.2rem;
            background: linear-gradient(45deg, #6b9fff, #ff69b4);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .undo-redo {
            display: flex;
            gap: 1rem;
        }

        .undo-redo button {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
        }

        .undo-redo button:disabled {
            opacity: 0.3;
        }

        .image-container {
            margin-top: 60px;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
        }

        #edited-image {
            max-width: 100%;
            max-height: calc(70vh - 60px);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .bottom-tools {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem;
        }

        .tools-scroll {
            display: flex;
            overflow-x: auto;
            gap: 1rem;
            padding-bottom: 0.5rem;
            scrollbar-width: none;
        }

        .tools-scroll::-webkit-scrollbar {
            display: none;
        }

        .tool-card {
            min-width: 80px;
            height: 80px;
            background: rgba(107, 159, 255, 0.1);
            border: 1px solid rgba(107, 159, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tool-card:active {
            transform: scale(0.95);
        }

        .tool-card i {
            font-size: 1.5rem;
            color: #6b9fff;
        }

        .tool-card span {
            font-size: 0.8rem;
            color: white;
        }

        .save-btn {
            position: fixed;
            bottom: calc(1rem + 100px);
            right: 1rem;
            background: linear-gradient(45deg, #6b9fff, #ff69b4);
            color: white;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }

        .history-stack {
            display: none;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <button class="back-btn" onclick="window.location.href='index.html'">‚Üê</button>
        <h1>Photo Editor</h1>
        <div class="undo-redo">
            <button onclick="undo()" id="undoBtn" disabled>‚Ü©</button>
            <button onclick="redo()" id="redoBtn" disabled>‚Ü™</button>
        </div>
    </div>

    <div class="image-container">
        <img id="edited-image" alt="Edited Image">
    </div>

    <button class="save-btn" onclick="saveImage()">üíæ</button>

    <div class="bottom-tools">
        <div class="tools-scroll">
            <div class="tool-card" onclick="window.location.href='filter.html'">
                <i>üé®</i>
                <span>Filters</span>
            </div>
            <div class="tool-card" onclick="window.location.href='effect.html'">
                <i>‚ú®</i>
                <span>Effects</span>
            </div>
            <div class="tool-card" onclick="window.location.href='addin.html'">
                <i>üñºÔ∏è</i>
                <span>Add Image</span>
            </div>
            <div class="tool-card" onclick="window.location.href='ai.html'">
                <i>ü§ñ</i>
                <span>AI</span>
            </div>
            <div class="tool-card" onclick="window.location.href='bg.html'">
                <i>üñºÔ∏è</i>
                <span>BG Remover</span>
            </div>
            <div class="tool-card" onclick="window.location.href='save.html'">
                <i>üíæ</i>
                <span>Save</span>
            </div>
            <div class="tool-card" onclick="window.location.href='brightness.html'">
                <i>‚òÄÔ∏è</i>
                <span>Brightness</span>
            </div>
            <div class="tool-card" onclick="window.location.href='contrast.html'">
                <i>‚óê</i>
                <span>Contrast</span>
            </div>
            <div class="tool-card" onclick="window.location.href='saturation.html'">
                <i>üåà</i>
                <span>Saturation</span>
            </div>
            <div class="tool-card" onclick="window.location.href='rotate.html'">
                <i>üîÑ</i>
                <span>Rotate</span>
            </div>
            <div class="tool-card" onclick="window.location.href='crop.html'">
                <i>‚úÇÔ∏è</i>
                <span>Crop</span>
            </div>
            <div class="tool-card" onclick="window.location.href='exposure.html'">
                <i>üí°</i>
                <span>Exposure</span>
            </div>
            <div class="tool-card" onclick="window.location.href='text.html'">
                <i>üìù</i>
                <span>Text</span>
            </div>
            <div class="tool-card" onclick="openVideoEditor()">
                <i>üé¨</i>
                <span>Video</span>
            </div>
        </div>
    </div>

    <div class="history-stack"></div>

    <!-- Video editor panel (in-page) -->
    <div id="videoPanel" style="display:none; position:fixed; inset:80px 40px 120px 40px; background:rgba(10,10,10,0.95); border-radius:12px; padding:18px; z-index:200; overflow:auto; box-shadow:0 8px 40px rgba(0,0,0,0.6)">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px">
            <h2 style="margin:0; font-size:1.1rem">Video Editor</h2>
            <div>
                <button onclick="closeVideoEditor()" style="background:none;border:1px solid rgba(255,255,255,0.08); color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer">Close</button>
            </div>
        </div>

        <div style="display:grid; grid-template-columns: 1fr 320px; gap:16px; align-items:start">
            <div>
                <input id="videoFile" type="file" accept="video/*" />
                <video id="editorVideo" controls style="width:100%; margin-top:12px; background:#000; border-radius:8px"></video>
                <div style="display:flex; gap:8px; align-items:center; margin-top:8px">
                    <button id="vePlay">Play</button>
                    <label>Current: <span id="veCurrent">0.00</span>s</label>
                    <label>Duration: <span id="veDuration">0.00</span>s</label>
                </div>

                <div style="display:flex; gap:8px; margin-top:10px; flex-wrap:wrap">
                    <label>Trim In <input id="veTrimIn" type="number" step="0.1" min="0" value="0" style="width:100px" /></label>
                    <button id="veSetIn">Set from current</button>
                    <label>Trim Out <input id="veTrimOut" type="number" step="0.1" min="0" value="0" style="width:100px" /></label>
                    <button id="veSetOut">Set from current</button>
                </div>
            </div>

            <div style="background:rgba(255,255,255,0.03); padding:12px; border-radius:8px">
                <strong>Filters</strong>
                <div style="display:flex; flex-direction:column; gap:8px; margin-top:8px">
                    <label>Brightness <input id="veBrightness" type="range" min="50" max="200" value="100" /></label>
                    <label>Contrast <input id="veContrast" type="range" min="50" max="200" value="100" /></label>
                    <label>Saturation <input id="veSaturation" type="range" min="0" max="300" value="100" /></label>
                </div>

                <div style="margin-top:12px; display:flex; flex-direction:column; gap:8px">
                    <button id="veExportOrig">Export (Original Format)</button>
                    <button id="veExportFast">Export (Fast WebM)</button>
                    <div id="veStatus" style="font-size:0.9rem; color:#ddd"></div>
                </div>
            </div>
        </div>
        <canvas id="veCanvas" style="display:none"></canvas>
    </div>

    <script>
        /* @ts-nocheck */
        /* global FFmpeg */
        let editHistory = [];
        let currentHistoryIndex = -1;
        let originalImage = null;

        window.onload = function() {
            const imageData = localStorage.getItem('editImage');
            if (imageData) {
                document.getElementById('edited-image').src = imageData;
                originalImage = imageData;
                addToHistory(imageData);
            }
        };

        function addToHistory(imageData) {
            if (!imageData) return;
            // avoid pushing duplicate consecutive states
            if (currentHistoryIndex >= 0 && editHistory[currentHistoryIndex] === imageData) {
                // same as current, ignore
                return;
            }
            // Remove any redo states
            if (currentHistoryIndex < editHistory.length - 1) {
                editHistory = editHistory.slice(0, currentHistoryIndex + 1);
            }

            editHistory.push(imageData);
            currentHistoryIndex++;
            // limit history size to prevent runaway memory usage
            const MAX_HISTORY = 50;
            if (editHistory.length > MAX_HISTORY) {
                const remove = editHistory.length - MAX_HISTORY;
                editHistory.splice(0, remove);
                currentHistoryIndex -= remove;
                if (currentHistoryIndex < 0) currentHistoryIndex = 0;
            }
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = currentHistoryIndex <= 0;
            document.getElementById('redoBtn').disabled = currentHistoryIndex >= editHistory.length - 1;
        }

        function undo() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                document.getElementById('edited-image').src = editHistory[currentHistoryIndex];
                localStorage.setItem('editImage', editHistory[currentHistoryIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (currentHistoryIndex < editHistory.length - 1) {
                currentHistoryIndex++;
                document.getElementById('edited-image').src = editHistory[currentHistoryIndex];
                localStorage.setItem('editImage', editHistory[currentHistoryIndex]);
                updateUndoRedoButtons();
            }
        }

        function adjustBrightness() {
            // Open brightness adjustment slider
            const value = prompt('Enter brightness value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `brightness(${100 + parseInt(value)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function adjustContrast() {
            const value = prompt('Enter contrast value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `contrast(${100 + parseInt(value)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function adjustSaturation() {
            const value = prompt('Enter saturation value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `saturate(${100 + parseInt(value)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function rotate() {
            const img = document.getElementById('edited-image');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalHeight;
            canvas.height = img.naturalWidth;
            
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(90 * Math.PI/180);
            ctx.drawImage(img, -img.naturalWidth/2, -img.naturalHeight/2);
            
            const newImageData = canvas.toDataURL('image/jpeg');
            img.src = newImageData;
            localStorage.setItem('editImage', newImageData);
            addToHistory(newImageData);
        }

        function crop() {
            alert('Tap and drag to select crop area (Not implemented in this demo)');
        }

        function adjustExposure() {
            const value = prompt('Enter exposure value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `brightness(${100 + parseInt(value)}%) contrast(${105 + parseInt(value/2)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function addText() {
            const text = prompt('Enter text to add:', '');
            if (text) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.drawImage(img, 0, 0);
                
                ctx.font = '48px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(text, canvas.width/2, canvas.height/2);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function saveImage() {
            const link = document.createElement('a');
            link.download = 'edited-image.jpg';
            link.href = document.getElementById('edited-image').src;
            link.click();
        }

        // Detect changes made by tool pages (they write to localStorage then navigate back)
        // When this page regains focus or becomes visible, check localStorage.editImage
        // and push a new history entry if it differs from current.
        function checkForExternalImageChange() {
            try {
                const stored = localStorage.getItem('editImage');
                if (!stored) return;
                const current = (currentHistoryIndex >= 0) ? editHistory[currentHistoryIndex] : null;
                if (stored !== current) {
                    // update displayed image and push to history
                    document.getElementById('edited-image').src = stored;
                    addToHistory(stored);
                }
            } catch (e) {
                // ignore storage access errors
                console.error('Error checking external image change', e);
            }
        }

        window.addEventListener('focus', checkForExternalImageChange);
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') checkForExternalImageChange();
        });

        // --- Video editor logic (namespaced to avoid conflicts) ---
        function openVideoEditor() {
            document.getElementById('videoPanel').style.display = 'block';
        }
        function closeVideoEditor() {
            document.getElementById('videoPanel').style.display = 'none';
            // stop any playback
            try { const v = document.getElementById('editorVideo'); v.pause(); } catch (e) {}
        }

        (function videoEditorInit(){
            const fileEl = document.getElementById('videoFile');
            const video = document.getElementById('editorVideo');
            const playBtn = document.getElementById('vePlay');
            const currentEl = document.getElementById('veCurrent');
            const durationEl = document.getElementById('veDuration');
            const trimInEl = document.getElementById('veTrimIn');
            const trimOutEl = document.getElementById('veTrimOut');
            const setIn = document.getElementById('veSetIn');
            const setOut = document.getElementById('veSetOut');
            const bEl = document.getElementById('veBrightness');
            const cEl = document.getElementById('veContrast');
            const sEl = document.getElementById('veSaturation');
            const exportOrig = document.getElementById('veExportOrig');
            const exportFast = document.getElementById('veExportFast');
            const statusEl = document.getElementById('veStatus');
            const canvas = document.getElementById('veCanvas');
            const ctx = canvas.getContext('2d');

            let fileObj = null;
            let ffmpeg = null;

            function updateFilterStyle(){
                video.style.filter = `brightness(${bEl.value}%) contrast(${cEl.value}%) saturate(${sEl.value}%)`;
            }
            bEl.addEventListener('input', updateFilterStyle);
            cEl.addEventListener('input', updateFilterStyle);
            sEl.addEventListener('input', updateFilterStyle);

            fileEl.addEventListener('change', e=>{
                const f = e.target.files && e.target.files[0];
                if (!f) return;
                fileObj = f;
                video.src = URL.createObjectURL(f);
                statusEl.textContent = '';
            });

            video.addEventListener('loadedmetadata', ()=>{
                durationEl.textContent = video.duration.toFixed(2);
                trimInEl.max = video.duration.toFixed(2);
                trimOutEl.max = video.duration.toFixed(2);
                trimOutEl.value = video.duration.toFixed(2);
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 360;
            });
            video.addEventListener('timeupdate', ()=>{ currentEl.textContent = video.currentTime.toFixed(2); });

            playBtn.addEventListener('click', ()=>{ if (video.paused){ video.play(); playBtn.textContent='Pause'; } else { video.pause(); playBtn.textContent='Play'; }});
            setIn.addEventListener('click', ()=>{ trimInEl.value = video.currentTime.toFixed(2); });
            setOut.addEventListener('click', ()=>{ trimOutEl.value = video.currentTime.toFixed(2); });

            async function ensureFFmpeg(){
                if (ffmpeg) return ffmpeg;
                statusEl.textContent = 'Loading ffmpeg (may take time)‚Ä¶';
                if (typeof FFmpeg === 'undefined'){
                    // load the bundled ffmpeg-wasm script
                    await new Promise((res, rej)=>{
                        const s = document.createElement('script');
                        s.src = 'https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js';
                        s.onload = res; s.onerror = rej; document.head.appendChild(s);
                    }).catch(e=>{ throw new Error('Failed to load ffmpeg script'); });
                }
                const { createFFmpeg, fetchFile } = FFmpeg;
                ffmpeg = createFFmpeg({ log: true });
                await ffmpeg.load();
                statusEl.textContent = 'ffmpeg ready';
                return ffmpeg;
            }

            // Export original format with ffmpeg.wasm (tries stream copy when no filters applied)
            exportOrig.addEventListener('click', async ()=>{
                if (!fileObj) { alert('Choose a video first'); return; }
                const start = parseFloat(trimInEl.value) || 0;
                const end = parseFloat(trimOutEl.value) || video.duration;
                if (start >= end){ alert('Trim In must be less than Trim Out'); return; }

                // warn about size / time
                statusEl.textContent = 'Preparing export‚Ä¶';
                try {
                    await ensureFFmpeg();
                    const ext = (fileObj.name.split('.').pop() || 'mp4').toLowerCase();
                    const inName = `input.${ext}`;
                    const outName = `output.${ext}`;
                    ffmpeg.FS('writeFile', inName, await FFmpeg.fetchFile(fileObj));

                    // if no filter changes, try stream copy (fast, no re-encode)
                    const noFilters = bEl.value==100 && cEl.value==100 && sEl.value==100;
                    try {
                        if (noFilters) {
                            statusEl.textContent = 'Running fast stream-copy (no re-encode)‚Ä¶';
                            // use -ss before -i for faster seek, but for accuracy use -ss after -i; we'll use -ss -to with input seek
                            await ffmpeg.run('-ss', `${start}`, '-to', `${end}`, '-i', inName, '-c', 'copy', outName);
                        } else {
                            throw new Error('filters-present');
                        }
                    } catch (copyErr) {
                        // fallback to re-encode (and apply visual filters if set)
                        statusEl.textContent = 'Stream-copy unavailable; re-encoding and applying filters (slower)‚Ä¶';
                        // map our sliders to ffmpeg eq parameters
                        const bVal = (parseInt(bEl.value) - 100) / 100; // -1..1
                        const cVal = (parseInt(cEl.value) / 100).toFixed(2); // multiplies contrast
                        const sVal = (parseInt(sEl.value) / 100).toFixed(2);
                        // ffmpeg eq filter uses brightness, contrast; saturation via eq or hue
                        const vf = `eq=brightness=${bVal}:contrast=${cVal},hue=s=${sVal}`;
                        // prefer libx264 + aac for mp4/mov, otherwise try libx264
                        const codecArgs = (ext==='mp4' || ext==='mov') ? ['-c:v','libx264','-c:a','aac'] : ['-c:v','libx264','-c:a','aac'];
                        await ffmpeg.run('-ss', `${start}`, '-to', `${end}`, '-i', inName, '-vf', vf, ...codecArgs, outName);
                    }

                    const data = ffmpeg.FS('readFile', outName);
                    const blob = new Blob([data.buffer], { type: fileObj.type || 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url; a.download = `trimmed.${ext}`; a.click();
                    statusEl.textContent = 'Export complete';
                } catch (e) {
                    console.error(e);
                    statusEl.textContent = 'Export failed: ' + (e && e.message ? e.message : e);
                    alert('Export failed. See console for details.');
                }
            });

            // Fast export using canvas capture (applies CSS filters) ‚Äî outputs WebM
            exportFast.addEventListener('click', async ()=>{
                if (!fileObj) { alert('Choose a video first'); return; }
                const start = parseFloat(trimInEl.value) || 0;
                const end = parseFloat(trimOutEl.value) || video.duration;
                if (start >= end){ alert('Trim In must be less than Trim Out'); return; }

                exportFast.disabled = true; statusEl.textContent = 'Exporting (fast WebM)‚Ä¶';
                canvas.width = video.videoWidth || 640; canvas.height = video.videoHeight || 360;
                let drawActive = true;
                const draw = ()=>{
                    if (!drawActive) return;
                    ctx.filter = `brightness(${bEl.value}%) contrast(${cEl.value}%) saturate(${sEl.value}%)`;
                    try { ctx.drawImage(video,0,0,canvas.width,canvas.height); } catch(e){}
                    requestAnimationFrame(draw);
                };
                const stream = canvas.captureStream(30);
                const recorded = [];
                let options = { mimeType: 'video/webm;codecs=vp9' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm;codecs=vp8' };
                let recorder;
                try { recorder = new MediaRecorder(stream, options); } catch(e){ alert('Recording not supported in this browser'); exportFast.disabled=false; statusEl.textContent=''; return; }
                recorder.ondataavailable = ev => { if (ev.data && ev.data.size) recorded.push(ev.data); };
                recorder.onstop = ()=>{
                    drawActive = false;
                    const blob = new Blob(recorded, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url; a.download = 'trimmed.webm'; a.click();
                    exportFast.disabled = false; statusEl.textContent = 'Fast export complete';
                };
                drawActive = true; draw(); recorded.length = 0; recorder.start();
                video.currentTime = start; await video.play();
                const onTime = ()=>{ if (video.currentTime >= end - 0.05){ video.pause(); try{ recorder.stop(); }catch(e){} video.removeEventListener('timeupdate', onTime); }};
                video.addEventListener('timeupdate', onTime);
            });

        })();
    </script>
</body>
</html>
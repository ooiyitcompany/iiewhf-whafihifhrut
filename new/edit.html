<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            min-height: 100vh;
            color: #fff;
            display: flex;
            flex-direction: column;
        }

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            z-index: 100;
        }

        .top-bar h1 {
            font-size: 1.2rem;
            background: linear-gradient(45deg, #6b9fff, #ff69b4);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .undo-redo {
            display: flex;
            gap: 1rem;
        }

        .undo-redo button {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
        }

        .undo-redo button:disabled {
            opacity: 0.3;
        }

        .image-container {
            margin-top: 60px;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            /* leave room for fixed bottom controls so tall images are fully visible */
            padding-bottom: 180px;
        }

        #edited-image {
            max-width: 100%;
            max-height: calc(70vh - 60px);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        /* Full-view mode hides chrome and lets image use more vertical space */
        body.full-view .top-bar,
        body.full-view .bottom-tools,
        body.full-view .save-btn,
        body.full-view #removeWatermarkBtn {
            display: none !important;
        }
        body.full-view #edited-image {
            max-height: calc(100vh - 20px) !important;
        }

        .bottom-tools {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem;
        }

        .tools-scroll {
            display: flex;
            overflow-x: auto;
            gap: 1rem;
            padding-bottom: 0.5rem;
            scrollbar-width: none;
        }

        .tools-scroll::-webkit-scrollbar {
            display: none;
        }

        .tool-card {
            min-width: 80px;
            height: 80px;
            background: rgba(107, 159, 255, 0.1);
            border: 1px solid rgba(107, 159, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tool-card:active {
            transform: scale(0.95);
        }

        .tool-card i {
            font-size: 1.5rem;
            color: #6b9fff;
        }

        .tool-card span {
            font-size: 0.8rem;
            color: white;
        }

        .save-btn {
            position: fixed;
            bottom: calc(1rem + 100px);
            right: 1rem;
            background: linear-gradient(45deg, #6b9fff, #ff69b4);
            color: white;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }

        .history-stack {
            display: none;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <button class="back-btn" onclick="window.location.href='index.html'"><i class="fa-solid fa-arrow-left"></i></button>
        <h1>Photo Editor</h1>
        <div class="undo-redo">
            <button onclick="undo()" id="undoBtn" disabled><i class="fa-solid fa-undo"></i></button>
            <button onclick="redo()" id="redoBtn" disabled><i class="fa-solid fa-redo"></i></button>
        </div>
    </div>

    <div class="image-container">
        <div style="position:relative; display:inline-block">
            <img id="edited-image" alt="Edited Image">
            <div id="watermark" style="position:absolute; right:16px; bottom:16px; color:rgba(255,255,255,0.7); font-size:20px; font-weight:600; pointer-events:auto; cursor:pointer; text-shadow:0 1px 2px rgba(0,0,0,0.6);">Ooiy</div>
        </div>
    </div>

    <button class="save-btn" onclick="saveImage()">ðŸ’¾</button>
    <!-- More button / dropdown -->
    <div style="position:fixed; bottom: calc(1rem + 160px); right:1rem; z-index:220; display:flex; flex-direction:column; gap:8px; align-items:flex-end">
        <button id="moreBtn" style="width:48px; height:48px; border-radius:8px; border:none; background:rgba(255,255,255,0.06); color:#fff; cursor:pointer">â‹®</button>
        <div id="moreMenu" style="display:none; background:rgba(11,11,11,0.95); padding:8px; border-radius:8px; box-shadow:0 8px 30px rgba(0,0,0,0.5); min-width:160px">
            <button id="toggleFullView" style="display:block; width:100%; text-align:left; padding:8px; border:none; background:none; color:#fff; cursor:pointer">Full View</button>
            <button id="openRemovePage" style="display:block; width:100%; text-align:left; padding:8px; border:none; background:none; color:#fff; cursor:pointer">Remove Watermark</button>
        </div>
    </div>
    
    <!-- Remove watermark control (kept for backward compatibility, hidden visually if using more menu) -->
    <button id="removeWatermarkBtn" style="position:fixed; bottom: calc(1rem + 160px); right:70px; width:48px; height:48px; border-radius:8px; border:none; background:rgba(255,255,255,0.06); color:#fff; cursor:pointer; display:none">âœ–</button>

    <div class="bottom-tools">
        <div class="tools-scroll">
            <div class="tool-card" onclick="window.location.href='filter.html'">
                <i class="fa-solid fa-palette"></i>
                <span>Filters</span>
            </div>
            <div class="tool-card" onclick="window.location.href='effect.html'">
                <i class="fa-solid fa-magic"></i>
                <span>Effects</span>
            </div>
            <div class="tool-card" onclick="window.location.href='addin.html'">
                <i class="fa-solid fa-image"></i>
                <span>Add Image</span>
            </div>
            <div class="tool-card" onclick="window.location.href='ai.html'">
                <i class="fa-solid fa-robot"></i>
                <span>AI</span>
            </div>
            <div class="tool-card" onclick="window.location.href='bg.html'">
                <i class="fa-solid fa-cut"></i>
                <span>BG Remover</span>
            </div>
            <div class="tool-card" onclick="window.location.href='save.html'">
                <i class="fa-solid fa-floppy-disk"></i>
                <span>Save</span>
            </div>
            <div class="tool-card" onclick="window.location.href='brightness.html'">
                <i class="fa-solid fa-sun"></i>
                <span>Brightness</span>
            </div>
            <div class="tool-card" onclick="window.location.href='contrast.html'">
                <i class="fa-solid fa-adjust"></i>
                <span>Contrast</span>
            </div>
            <div class="tool-card" onclick="window.location.href='saturation.html'">
                <i class="fa-solid fa-droplet"></i>
                <span>Saturation</span>
            </div>
            <div class="tool-card" onclick="window.location.href='rotate.html'">
                <i class="fa-solid fa-rotate-right"></i>
                <span>Rotate</span>
            </div>
            <div class="tool-card" onclick="window.location.href='crop.html'">
                <i class="fa-solid fa-crop"></i>
                <span>Crop</span>
            </div>
            <div class="tool-card" onclick="window.location.href='exposure.html'">
                <i class="fa-solid fa-lightbulb"></i>
                <span>Exposure</span>
            </div>
            <div class="tool-card" onclick="window.location.href='text.html'">
                <i class="fa-solid fa-font"></i>
                <span>Text</span>
            </div>
            <div class="tool-card" onclick="openVideoEditor()">
                <i class="fa-solid fa-video"></i>
                <span>Video</span>
            </div>
            <div class="tool-card" onclick="window.location.href='resize.html'">
                <i class="fa-solid fa-expand"></i>
                <span>Resize</span>
            </div>
            <div class="tool-card" onclick="window.location.href='compress.html'">
                <i class="fa-solid fa-compress"></i>
                <span>Compress</span>
            </div>
        </div>
    </div>

    <div class="history-stack"></div>

    <!-- Modal: remove watermark prompt -->
    <div id="removeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:300; align-items:center; justify-content:center;">
        <div style="background:#0b0b0b; padding:18px; border-radius:12px; width:320px; color:#fff; box-shadow:0 10px 40px rgba(0,0,0,0.6);">
            <h3 style="margin:0 0 8px 0">Remove watermark</h3>
            <p style="color:#ccc; font-size:0.95rem">Watch a short rewarded video to be taken to the Pro page, or cancel. To permanently remove the watermark without watching, open Remove page and tap Remove.</p>
            <div style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end">
                <button id="modalCancel" style="background:none;border:1px solid rgba(255,255,255,0.08); color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer">Cancel</button>
                <button id="modalWatch" style="background:linear-gradient(45deg,#6b9fff,#ff69b4); color:#fff; padding:8px 10px; border-radius:8px; border:none; cursor:pointer">Watch</button>
            </div>
        </div>
    </div>

    <!-- Video editor panel (in-page) -->
    <div id="videoPanel" style="display:none; position:fixed; inset:80px 40px 120px 40px; background:rgba(10,10,10,0.95); border-radius:12px; padding:18px; z-index:200; overflow:auto; box-shadow:0 8px 40px rgba(0,0,0,0.6)">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px">
            <h2 style="margin:0; font-size:1.1rem">Video Editor</h2>
            <div>
                <button onclick="closeVideoEditor()" style="background:none;border:1px solid rgba(255,255,255,0.08); color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer">Close</button>
            </div>
        </div>

        <div style="display:grid; grid-template-columns: 1fr 320px; gap:16px; align-items:start">
            <div>
                <input id="videoFile" type="file" accept="video/*" />
                <video id="editorVideo" controls style="width:100%; margin-top:12px; background:#000; border-radius:8px"></video>
                <div style="display:flex; gap:8px; align-items:center; margin-top:8px">
                    <button id="vePlay">Play</button>
                    <label>Current: <span id="veCurrent">0.00</span>s</label>
                    <label>Duration: <span id="veDuration">0.00</span>s</label>
                </div>

                <div style="display:flex; gap:8px; margin-top:10px; flex-wrap:wrap">
                    <label>Trim In <input id="veTrimIn" type="number" step="0.1" min="0" value="0" style="width:100px" /></label>
                    <button id="veSetIn">Set from current</button>
                    <label>Trim Out <input id="veTrimOut" type="number" step="0.1" min="0" value="0" style="width:100px" /></label>
                    <button id="veSetOut">Set from current</button>
                </div>
            </div>

            <div style="background:rgba(255,255,255,0.03); padding:12px; border-radius:8px">
                <strong>Filters</strong>
                <div style="display:flex; flex-direction:column; gap:8px; margin-top:8px">
                    <label>Brightness <input id="veBrightness" type="range" min="50" max="200" value="100" /></label>
                    <label>Contrast <input id="veContrast" type="range" min="50" max="200" value="100" /></label>
                    <label>Saturation <input id="veSaturation" type="range" min="0" max="300" value="100" /></label>
                </div>

                <div style="margin-top:12px; display:flex; flex-direction:column; gap:8px">
                    <button id="veExportOrig">Export (Original Format)</button>
                    <button id="veExportFast">Export (Fast WebM)</button>
                    <div id="veStatus" style="font-size:0.9rem; color:#ddd"></div>
                </div>
            </div>
        </div>
        <canvas id="veCanvas" style="display:none"></canvas>
    </div>

    <script>
        /* @ts-nocheck */
        /* global FFmpeg */
        let editHistory = [];
        let currentHistoryIndex = -1;
        let originalImage = null;

        window.onload = function() {
            const imageData = localStorage.getItem('editImage');
            if (imageData) {
                document.getElementById('edited-image').src = imageData;
                originalImage = imageData;
                addToHistory(imageData);
            }
        };

        function addToHistory(imageData) {
            if (!imageData) return;
            // avoid pushing duplicate consecutive states
            if (currentHistoryIndex >= 0 && editHistory[currentHistoryIndex] === imageData) {
                // same as current, ignore
                return;
            }
            // Remove any redo states
            if (currentHistoryIndex < editHistory.length - 1) {
                editHistory = editHistory.slice(0, currentHistoryIndex + 1);
            }

            editHistory.push(imageData);
            currentHistoryIndex++;
            // limit history size to prevent runaway memory usage
            const MAX_HISTORY = 50;
            if (editHistory.length > MAX_HISTORY) {
                const remove = editHistory.length - MAX_HISTORY;
                editHistory.splice(0, remove);
                currentHistoryIndex -= remove;
                if (currentHistoryIndex < 0) currentHistoryIndex = 0;
            }
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = currentHistoryIndex <= 0;
            document.getElementById('redoBtn').disabled = currentHistoryIndex >= editHistory.length - 1;
        }

        function undo() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                document.getElementById('edited-image').src = editHistory[currentHistoryIndex];
                localStorage.setItem('editImage', editHistory[currentHistoryIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (currentHistoryIndex < editHistory.length - 1) {
                currentHistoryIndex++;
                document.getElementById('edited-image').src = editHistory[currentHistoryIndex];
                localStorage.setItem('editImage', editHistory[currentHistoryIndex]);
                updateUndoRedoButtons();
            }
        }

        function adjustBrightness() {
            // Open brightness adjustment slider
            const value = prompt('Enter brightness value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `brightness(${100 + parseInt(value)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function adjustContrast() {
            const value = prompt('Enter contrast value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `contrast(${100 + parseInt(value)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function adjustSaturation() {
            const value = prompt('Enter saturation value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `saturate(${100 + parseInt(value)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function rotate() {
            const img = document.getElementById('edited-image');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalHeight;
            canvas.height = img.naturalWidth;
            
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(90 * Math.PI/180);
            ctx.drawImage(img, -img.naturalWidth/2, -img.naturalHeight/2);
            
            const newImageData = canvas.toDataURL('image/jpeg');
            img.src = newImageData;
            localStorage.setItem('editImage', newImageData);
            addToHistory(newImageData);
        }

        function crop() {
            alert('Tap and drag to select crop area (Not implemented in this demo)');
        }

        function adjustExposure() {
            const value = prompt('Enter exposure value (-100 to 100):', '0');
            if (value !== null) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.filter = `brightness(${100 + parseInt(value)}%) contrast(${105 + parseInt(value/2)}%)`;
                ctx.drawImage(img, 0, 0);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function addText() {
            const text = prompt('Enter text to add:', '');
            if (text) {
                const img = document.getElementById('edited-image');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.drawImage(img, 0, 0);
                
                ctx.font = '48px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(text, canvas.width/2, canvas.height/2);
                
                const newImageData = canvas.toDataURL('image/jpeg');
                img.src = newImageData;
                localStorage.setItem('editImage', newImageData);
                addToHistory(newImageData);
            }
        }

        function saveImage() {
            // Credit-based watermark removal: user may have N credits to save without watermark
            const credits = parseInt(localStorage.getItem('ooiy_watermark_credits') || '0', 10);
            const useCredit = credits > 0;

            const img = document.getElementById('edited-image');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            ctx.drawImage(img, 0, 0);

            if (!useCredit) {
                // draw watermark at bottom-right with padding proportional to size
                const padding = Math.round(canvas.width * 0.02);
                const fontSize = Math.round(canvas.width * 0.04);
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.fillStyle = 'rgba(255,255,255,0.75)';
                ctx.textBaseline = 'bottom';
                const text = 'Ooiy';
                const metrics = ctx.measureText(text);
                const x = canvas.width - metrics.width - padding;
                const y = canvas.height - padding;
                ctx.fillText(text, x, y);
            }

            const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
            const link = document.createElement('a');
            link.download = 'edited-image.jpg';
            link.href = dataUrl;
            link.click();

            if (useCredit) {
                // consume one credit
                localStorage.setItem('ooiy_watermark_credits', String(Math.max(0, credits - 1)));
                // notify listeners so UI refreshes
                window.dispatchEvent(new StorageEvent('storage', { key: 'ooiy_watermark_credits', newValue: String(Math.max(0, credits - 1)) }));
            }
        }

        // Detect changes made by tool pages (they write to localStorage then navigate back)
        // When this page regains focus or becomes visible, check localStorage.editImage
        // and push a new history entry if it differs from current.
        function checkForExternalImageChange() {
            try {
                const stored = localStorage.getItem('editImage');
                if (!stored) return;
                const current = (currentHistoryIndex >= 0) ? editHistory[currentHistoryIndex] : null;
                if (stored !== current) {
                    // update displayed image and push to history
                    document.getElementById('edited-image').src = stored;
                    addToHistory(stored);
                }
            } catch (e) {
                // ignore storage access errors
                console.error('Error checking external image change', e);
            }
        }

        window.addEventListener('focus', checkForExternalImageChange);
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') checkForExternalImageChange();
        });

        // --- Video editor logic (namespaced to avoid conflicts) ---
        function openVideoEditor() {
            document.getElementById('videoPanel').style.display = 'block';
        }
        function closeVideoEditor() {
            document.getElementById('videoPanel').style.display = 'none';
            // stop any playback
            try { const v = document.getElementById('editorVideo'); v.pause(); } catch (e) {}
        }

        (function videoEditorInit(){
            const fileEl = document.getElementById('videoFile');
            const video = document.getElementById('editorVideo');
            const playBtn = document.getElementById('vePlay');
            const currentEl = document.getElementById('veCurrent');
            const durationEl = document.getElementById('veDuration');
            const trimInEl = document.getElementById('veTrimIn');
            const trimOutEl = document.getElementById('veTrimOut');
            const setIn = document.getElementById('veSetIn');
            const setOut = document.getElementById('veSetOut');
            const bEl = document.getElementById('veBrightness');
            const cEl = document.getElementById('veContrast');
            const sEl = document.getElementById('veSaturation');
            const exportOrig = document.getElementById('veExportOrig');
            const exportFast = document.getElementById('veExportFast');
            const statusEl = document.getElementById('veStatus');
            const canvas = document.getElementById('veCanvas');
            const ctx = canvas.getContext('2d');

            let fileObj = null;
            let ffmpeg = null;

            function updateFilterStyle(){
                video.style.filter = `brightness(${bEl.value}%) contrast(${cEl.value}%) saturate(${sEl.value}%)`;
            }
            bEl.addEventListener('input', updateFilterStyle);
            cEl.addEventListener('input', updateFilterStyle);
            sEl.addEventListener('input', updateFilterStyle);

            fileEl.addEventListener('change', e=>{
                const f = e.target.files && e.target.files[0];
                if (!f) return;
                fileObj = f;
                video.src = URL.createObjectURL(f);
                statusEl.textContent = '';
            });

            video.addEventListener('loadedmetadata', ()=>{
                durationEl.textContent = video.duration.toFixed(2);
                trimInEl.max = video.duration.toFixed(2);
                trimOutEl.max = video.duration.toFixed(2);
                trimOutEl.value = video.duration.toFixed(2);
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 360;
            });
            video.addEventListener('timeupdate', ()=>{ currentEl.textContent = video.currentTime.toFixed(2); });

            playBtn.addEventListener('click', ()=>{ if (video.paused){ video.play(); playBtn.textContent='Pause'; } else { video.pause(); playBtn.textContent='Play'; }});
            setIn.addEventListener('click', ()=>{ trimInEl.value = video.currentTime.toFixed(2); });
            setOut.addEventListener('click', ()=>{ trimOutEl.value = video.currentTime.toFixed(2); });

            async function ensureFFmpeg(){
                if (ffmpeg) return ffmpeg;
                statusEl.textContent = 'Loading ffmpeg (may take time)â€¦';
                if (typeof FFmpeg === 'undefined'){
                    // load the bundled ffmpeg-wasm script
                    await new Promise((res, rej)=>{
                        const s = document.createElement('script');
                        s.src = 'https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js';
                        s.onload = res; s.onerror = rej; document.head.appendChild(s);
                    }).catch(e=>{ throw new Error('Failed to load ffmpeg script'); });
                }
                const { createFFmpeg, fetchFile } = FFmpeg;
                ffmpeg = createFFmpeg({ log: true });
                await ffmpeg.load();
                statusEl.textContent = 'ffmpeg ready';
                return ffmpeg;
            }

            // Export original format with ffmpeg.wasm (tries stream copy when no filters applied)
            exportOrig.addEventListener('click', async ()=>{
                if (!fileObj) { alert('Choose a video first'); return; }
                const start = parseFloat(trimInEl.value) || 0;
                const end = parseFloat(trimOutEl.value) || video.duration;
                if (start >= end){ alert('Trim In must be less than Trim Out'); return; }

                // warn about size / time
                statusEl.textContent = 'Preparing exportâ€¦';
                try {
                    await ensureFFmpeg();
                    const ext = (fileObj.name.split('.').pop() || 'mp4').toLowerCase();
                    const inName = `input.${ext}`;
                    const outName = `output.${ext}`;
                    ffmpeg.FS('writeFile', inName, await FFmpeg.fetchFile(fileObj));

                    // if no filter changes, try stream copy (fast, no re-encode)
                    const noFilters = bEl.value==100 && cEl.value==100 && sEl.value==100;
                    try {
                        if (noFilters) {
                            statusEl.textContent = 'Running fast stream-copy (no re-encode)â€¦';
                            // use -ss before -i for faster seek, but for accuracy use -ss after -i; we'll use -ss -to with input seek
                            await ffmpeg.run('-ss', `${start}`, '-to', `${end}`, '-i', inName, '-c', 'copy', outName);
                        } else {
                            throw new Error('filters-present');
                        }
                    } catch (copyErr) {
                        // fallback to re-encode (and apply visual filters if set)
                        statusEl.textContent = 'Stream-copy unavailable; re-encoding and applying filters (slower)â€¦';
                        // map our sliders to ffmpeg eq parameters
                        const bVal = (parseInt(bEl.value) - 100) / 100; // -1..1
                        const cVal = (parseInt(cEl.value) / 100).toFixed(2); // multiplies contrast
                        const sVal = (parseInt(sEl.value) / 100).toFixed(2);
                        // ffmpeg eq filter uses brightness, contrast; saturation via eq or hue
                        const vf = `eq=brightness=${bVal}:contrast=${cVal},hue=s=${sVal}`;
                        // prefer libx264 + aac for mp4/mov, otherwise try libx264
                        const codecArgs = (ext==='mp4' || ext==='mov') ? ['-c:v','libx264','-c:a','aac'] : ['-c:v','libx264','-c:a','aac'];
                        await ffmpeg.run('-ss', `${start}`, '-to', `${end}`, '-i', inName, '-vf', vf, ...codecArgs, outName);
                    }

                    const data = ffmpeg.FS('readFile', outName);
                    const blob = new Blob([data.buffer], { type: fileObj.type || 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url; a.download = `trimmed.${ext}`; a.click();
                    statusEl.textContent = 'Export complete';
                } catch (e) {
                    console.error(e);
                    statusEl.textContent = 'Export failed: ' + (e && e.message ? e.message : e);
                    alert('Export failed. See console for details.');
                }
            });

            // Fast export using canvas capture (applies CSS filters) â€” outputs WebM
            exportFast.addEventListener('click', async ()=>{
                if (!fileObj) { alert('Choose a video first'); return; }
                const start = parseFloat(trimInEl.value) || 0;
                const end = parseFloat(trimOutEl.value) || video.duration;
                if (start >= end){ alert('Trim In must be less than Trim Out'); return; }

                exportFast.disabled = true; statusEl.textContent = 'Exporting (fast WebM)â€¦';
                canvas.width = video.videoWidth || 640; canvas.height = video.videoHeight || 360;
                let drawActive = true;
                const draw = ()=>{
                    if (!drawActive) return;
                    ctx.filter = `brightness(${bEl.value}%) contrast(${cEl.value}%) saturate(${sEl.value}%)`;
                    try { ctx.drawImage(video,0,0,canvas.width,canvas.height); } catch(e){}
                    requestAnimationFrame(draw);
                };
                const stream = canvas.captureStream(30);
                const recorded = [];
                let options = { mimeType: 'video/webm;codecs=vp9' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm;codecs=vp8' };
                let recorder;
                try { recorder = new MediaRecorder(stream, options); } catch(e){ alert('Recording not supported in this browser'); exportFast.disabled=false; statusEl.textContent=''; return; }
                recorder.ondataavailable = ev => { if (ev.data && ev.data.size) recorded.push(ev.data); };
                recorder.onstop = ()=>{
                    drawActive = false;
                    const blob = new Blob(recorded, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url; a.download = 'trimmed.webm'; a.click();
                    exportFast.disabled = false; statusEl.textContent = 'Fast export complete';
                };
                drawActive = true; draw(); recorded.length = 0; recorder.start();
                video.currentTime = start; await video.play();
                const onTime = ()=>{ if (video.currentTime >= end - 0.05){ video.pause(); try{ recorder.stop(); }catch(e){} video.removeEventListener('timeupdate', onTime); }};
                video.addEventListener('timeupdate', onTime);
            });

        })();

        // --- Watermark & remove flow ---
        (function watermarkInit(){
            const watermarkEl = document.getElementById('watermark');
            const removeBtn = document.getElementById('removeWatermarkBtn');
            // transient cancel button shown when watermark is tapped
            let transientCancel = null;
            const modal = document.getElementById('removeModal');
            const modalCancel = document.getElementById('modalCancel');
            const modalWatch = document.getElementById('modalWatch');

            function refreshWatermarkVisibility(){
                const credits = parseInt(localStorage.getItem('ooiy_watermark_credits') || '0', 10);
                // hide watermark when user has credits available
                watermarkEl.style.display = (credits > 0) ? 'none' : 'block';
            }
            refreshWatermarkVisibility();

            // Clicking the small remove icon opens modal to offer watch or cancel
            removeBtn.addEventListener('click', ()=>{ modal.style.display = 'flex'; });

            // When user taps watermark, show a small Cancel button and a link to Remove page
            watermarkEl.addEventListener('click', (e)=>{
                // create transient cancel button if not present
                if (transientCancel) return;
                transientCancel = document.createElement('button');
                transientCancel.textContent = 'Cancel';
                transientCancel.style.position = 'absolute';
                transientCancel.style.right = '16px';
                transientCancel.style.bottom = '48px';
                transientCancel.style.padding = '6px 10px';
                transientCancel.style.borderRadius = '8px';
                transientCancel.style.border = 'none';
                transientCancel.style.background = 'rgba(0,0,0,0.6)';
                transientCancel.style.color = '#fff';
                transientCancel.style.zIndex = '500';
                transientCancel.addEventListener('click', ()=>{
                    // go to remove page (watch reward ads)
                    window.location.href = 'remove.html';
                });
                document.querySelector('.image-container').appendChild(transientCancel);
                // remove after 4 seconds if untouched
                setTimeout(()=>{ if (transientCancel && transientCancel.parentNode) transientCancel.parentNode.removeChild(transientCancel); transientCancel = null; }, 4000);
            });
            modalCancel.addEventListener('click', ()=>{ modal.style.display = 'none'; });

            // Watch button navigates to pro.html (reward flow handled by app or pro page)
            modalWatch.addEventListener('click', ()=>{
                // close modal then redirect to pro.html where the ad/reward is shown
                modal.style.display = 'none';
                window.location.href = 'pro.html';
            });

            // Also, allow remove via remove.html page: if the flag is set in storage, hide watermark
            window.addEventListener('storage', (e)=>{ if (e.key === 'ooiy_watermark_removed') refreshWatermarkVisibility(); });
        })();

        // --- More menu / full-view behavior ---
        (function moreMenuInit(){
            const moreBtn = document.getElementById('moreBtn');
            const moreMenu = document.getElementById('moreMenu');
            const toggleFull = document.getElementById('toggleFullView');
            const openRemove = document.getElementById('openRemovePage');
            const goPro = document.getElementById('goPro');

            moreBtn.addEventListener('click', (e)=>{
                e.stopPropagation();
                moreMenu.style.display = moreMenu.style.display === 'block' ? 'none' : 'block';
            });
            // close menu when clicking elsewhere
            window.addEventListener('click', ()=>{ moreMenu.style.display = 'none'; });
            moreMenu.addEventListener('click', (e)=>{ e.stopPropagation(); });

            toggleFull.addEventListener('click', ()=>{
                document.body.classList.toggle('full-view');
                moreMenu.style.display = 'none';
            });
            openRemove.addEventListener('click', ()=>{ window.location.href = 'remove.html'; });
            goPro.addEventListener('click', ()=>{ window.location.href = 'pro.html'; });
        })();
    </script>
</body>
</html>